typedef struct RGBA{\nint r;\nint g;\nint b;\nint a;\n}RGBA;\nRGBA intToRgba(int rgb) {\nRGBA rgba;\nrgba.r = (rgb >> 16) & 0xff;\nrgba.g = (rgb >>  8) & 0xff;\nrgba.b = (rgb  ) & 0xff;\nrgba.a = (rgb >> 24) & 0xff;\nreturn rgba;\n}\nint rgbToInt(int r,int g,int b) {\nif(r>255) {\nr=255;\n}\nif(g>255) {\ng=255;\n}\nif(b>255) {\nb=255;\n}\nif(r<0) {\nr=0;\n}\nif(g<0) {\ng=0;\n}\nif(b<0) {\nb=0;\n}\nreturn 0xFF000000 | ((r << 16) & 0x00FF0000) | ((g << 8) & 0x0000FF00) | (b & 0x000000FF);\n}\nint colorDistance(int r1,int g1,int b1, int r2,int g2,int b2) {\nint rmean = (b1 + b2) / 2;\nint r = r1 - r2;\nint g = g1 - g2;\nint b = b1 - b2;\nreturn (int)(sqrt((float)((((512+rmean)*r*r)>>8) + 4*g*g + (((767-rmean)*b*b)>>8))));\n}\nint getNearlyColor(__global int *palette,int colorCount,RGBA rgb) {\nint c1=rgb.r;\nint c2=rgb.g;\nint c3=rgb.b;\nRGBA minColor= intToRgba(palette[0]);\nint m1 = minColor.r;\nint m2 = minColor.g;\nint m3 = minColor.b;\nint min = colorDistance(m1,m2,m3,c1,c2,c3);\nint minIndex = 0;\nfor (int i=1;i<colorCount;i++) {\nRGBA tempColor = intToRgba(palette[i]);\nint t1 = tempColor.r;\nint t2 = tempColor.g;\nint t3 = tempColor.b;\nint temp = colorDistance(t1,t2,t3,c1,c2,c3);\nif(temp<min) {\nmin = temp;\nminIndex = i;\nm1=t1;\nm2=t2;\nm3=t3;\n}\n}\nreturn minIndex+4;\n}\n__kernel void dither(__global int *colors,__global int *palette,__global int *settings,__global char *result) {\nint id = get_global_id(0);\nint width = settings[0];\nint colorCount = settings[1];\nRGBA rgba = intToRgba(colors[id]);\nint near = getNearlyColor(palette, colorCount, rgba);\nresult[id] = (char)((near / 4) << 2 | (near % 4) & 3);\n}