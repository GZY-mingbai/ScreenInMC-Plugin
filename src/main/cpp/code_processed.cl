float hslDistance(float* h1, float* h2) {\nconst float pi=3.1415926;\nconst float r=0.999958243;\nconst float h=0.00913839539;\nfloat x1 = r * h1[2] * h1[1] * cos(h1[0] / 2 * pi);\nfloat y1 = r * h1[2] * h1[1] * sin(h1[0] / 2 * pi);\nfloat z1 = h * (1 - h1[2]);\nfloat x2 = r * h2[2] * h2[1] * cos(h2[0] / 2 * pi);\nfloat y2 = r * h2[2] * h2[1] * sin(h2[0] / 2 * pi);\nfloat z2 = h * (1 - h2[2]);\nfloat dx = x1 - x2;\nfloat dy = y1 - y2;\nfloat dz = z1 - z2;\nreturn sqrt(dx * dx + dy * dy + dz * dz);\n}\nfloat* rgbToHsl(int* rgb)\n{\nfloat H,S,L;\nfloat r = rgb[0];\nfloat g = rgb[1];\nfloat b = rgb[2];\nr = r / 255.0;\ng = g / 255.0;\nb = b / 255.0;\nfloat M = max(max(r, g), b);\nfloat m = min(min(r, g), b);\nfloat d = M - m;\nif (d == 0) H = 0;\nelse if (M == r)\n{\nH = ((g - b) / d);\nH = H + ((int)H % 6);\n}\nelse if (M == g) H = (b - r) / d + 2;\nelse H = (r - g) / d + 4;\nH *= 60;\nif (H < 0) H += 360;\nL = (M + m) / 2;\nif (d == 0)\nS = 0;\nelse\nS = d / (1 - fabs(2 * L - 1));\nH/=360.0;\nfloat hsl[3]={H,S,L};\nreturn hsl;\n}\nint* intToRgb(int rgb) {\nint result[3];\nresult[0] = (rgb >> 16) & 0xff;\nresult[1] = (rgb >>  8) & 0xff;\nresult[2] = (rgb  ) & 0xff;\nreturn result;\n}\nint* intToRgba(int rgb) {\nint result[4];\nresult[0] = (rgb >> 16) & 0xff;\nresult[1] = (rgb >>  8) & 0xff;\nresult[2] = (rgb) & 0xff;\nresult[3] = (rgb >> 24) & 0xff;\nreturn result;\n}\nfloat* closestColors(float *hsl,__global int *colors,int colorCount) {\nfloat closest[4] = { -2, 0, 0 ,-4};\nfloat secondClosest[4] = {-2, 0, 0, -4};\nfloat temp[4];\nfor (int i = 0; i < colorCount; ++i) {\ntemp[0]=((float)colors[i*3])/360.0;\ntemp[1]=((float)colors[i*3+1])/255.0;\ntemp[2]=((float)colors[i*3+2])/255.0;\ntemp[3]=i;\nfloat tempDistance = hslDistance(temp, hsl);\nif (tempDistance < hslDistance(closest, hsl)) {\nsecondClosest[0] = closest[0];\nsecondClosest[1] = closest[1];\nsecondClosest[2] = closest[2];\nsecondClosest[3] = closest[3];\nclosest[0] = temp[0];\nclosest[1] = temp[1];\nclosest[2] = temp[2];\nclosest[3] = temp[3];\n}\nelse {\nif (tempDistance < hslDistance(secondClosest, hsl)) {\nsecondClosest[0] = temp[0];\nsecondClosest[1] = temp[1];\nsecondClosest[2] = temp[2];\nsecondClosest[3] = temp[3];\n}\n}\n}\nfloat ret[8];\nret[0] = closest[0];\nret[1] = closest[1];\nret[2] = closest[2];\nret[3] = secondClosest[0];\nret[4] = secondClosest[1];\nret[5] = secondClosest[2];\nret[6] = closest[3];\nret[7] = secondClosest[3];\nreturn ret;\n\n}\nfloat indexValue(int width,int index) {\nint y = index / width;\nint x = index % width;\nint indexMatrix[64] = {0,  32, 8,  40, 2,  34, 10, 42,\n48, 16, 56, 24, 50, 18, 58, 26,\n12, 44, 4,  36, 14, 46, 6,  38,\n60, 28, 52, 20, 62, 30, 54, 22,\n3,  35, 11, 43, 1,  33, 9,  41,\n51, 19, 59, 27, 49, 17, 57, 25,\n15, 47, 7,  39, 13, 45, 5,  37,\n63, 31, 55, 23, 61, 29, 53, 21};\nreturn indexMatrix[(x%8) + (y%8) * 8] / 64.0;\n}\n__kernel void dither(__global int *image,__global int *palette,__global int *settings,__global char *result) {\nint colorCount = settings[2];\nint id = get_global_id(0);\nint* rgba = intToRgba(image[id]);\nif(rgba[3]!=255){\nresult[id]=0;\nreturn;\n}\nint rgb[3] = {rgba[0],rgba[1],rgba[2]};\nfloat* hsl = rgbToHsl(rgb);\nfloat* cs = closestColors(hsl,palette,colorCount);\nfloat c1[4] = {cs[0],cs[1],cs[2],cs[6]+4};\nfloat c2[4] = {cs[3],cs[4],cs[5],cs[7]+4};\nfloat d = indexValue(settings[0],id);\nfloat hslDiff = hslDistance(hsl, c1) / hslDistance(c2, c1);\nresult[id] = (char) (hslDiff < d ? (int)c1[3] : (int)c2[3]);\n}